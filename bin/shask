#!/usr/bin/env bash
set -euo pipefail

usage() {
  echo "Usage: shask [--explain|--no-explain] [--raw] [--model MODEL] <question...>" >&2
}

spinner_pid=""
clipboard_cmd=()
state_dir="${XDG_STATE_HOME:-$HOME/.local/state}/shask"
state_file="${state_dir}/last.json"
last_question=""
last_cmd=""
last_why=""

start_spinner() {
  if [[ ! -t 2 ]]; then
    return 0
  fi

  local frames='|/-\'
  local i=0
  (
    while :; do
      printf '\r%s' "${frames:i++%4:1}" >&2
      sleep 0.1
    done
  ) &
  spinner_pid=$!
}

stop_spinner() {
  if [[ -z "${spinner_pid}" ]]; then
    return 0
  fi

  kill "${spinner_pid}" 2>/dev/null || true
  wait "${spinner_pid}" 2>/dev/null || true
  spinner_pid=""
  printf '\r \r' >&2
}

trap stop_spinner EXIT

is_tty_output() {
  [[ -t 1 ]]
}

is_tty_input() {
  [[ -t 0 ]]
}

color_enabled() {
  [[ -t 1 && -z "${NO_COLOR:-}" && "${TERM:-}" != "dumb" ]]
}

detect_clipboard_cmd() {
  if command -v pbcopy >/dev/null 2>&1; then
    clipboard_cmd=(pbcopy)
    return 0
  fi
  if command -v wl-copy >/dev/null 2>&1; then
    clipboard_cmd=(wl-copy)
    return 0
  fi
  if command -v xclip >/dev/null 2>&1; then
    clipboard_cmd=(xclip -selection clipboard)
    return 0
  fi
  if command -v xsel >/dev/null 2>&1; then
    clipboard_cmd=(xsel --clipboard --input)
    return 0
  fi
  return 1
}

print_command() {
  local label="Command:"
  if color_enabled; then
    label=$'\033[90mCommand:\033[0m'
  fi
  if is_tty_output; then
    printf '%s %s\n' "$label" "$cmd"
  else
    printf '%s\n' "$cmd"
  fi
}

prompt_copy_to_clipboard() {
  if ! is_tty_input || ! is_tty_output; then
    return 0
  fi
  if ! detect_clipboard_cmd; then
    return 0
  fi
  printf 'Copy to clipboard? [Y/n] ' >&2
  local reply=""
  if ! IFS= read -r reply; then
    return 0
  fi
  reply="$(printf '%s' "$reply" | tr '[:upper:]' '[:lower:]')"
  if [[ -z "$reply" || "$reply" == "y" || "$reply" == "yes" ]]; then
    printf '%s' "$cmd" | "${clipboard_cmd[@]}" >/dev/null 2>&1 || true
  fi
}

read_last_context() {
  last_question=""
  last_cmd=""
  last_why=""
  if [[ ! -f "$state_file" ]]; then
    return 0
  fi
  if ! command -v python3 >/dev/null 2>&1; then
    return 0
  fi
  local output
  local status
  set +e
  output=$(
    python3 - "$state_file" <<'PY'
import json
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
except Exception:
    sys.exit(1)

def clean(value):
    if value is None:
        return ""
    if not isinstance(value, str):
        value = str(value)
    return value.replace("\n", " ").strip()

print(clean(data.get("question", "")))
print(clean(data.get("cmd", "")))
print(clean(data.get("why", "")))
PY
  )
  status=$?
  set -e
  if [[ $status -ne 0 ]]; then
    return 0
  fi
  mapfile -t lines <<<"$output"
  last_question="${lines[0]:-}"
  last_cmd="${lines[1]:-}"
  last_why="${lines[2]:-}"
}

write_last_context() {
  if ! command -v python3 >/dev/null 2>&1; then
    return 0
  fi
  local tmp_file=""
  local status
  set +e
  mkdir -p "$state_dir"
  status=$?
  if [[ $status -ne 0 ]]; then
    set -e
    return 0
  fi
  tmp_file="$(mktemp "${state_dir}/.last.json.XXXXXX")"
  status=$?
  if [[ $status -ne 0 || -z "$tmp_file" ]]; then
    set -e
    return 0
  fi
  python3 - "$tmp_file" "$user_request" "$cmd" "$why" "$model" <<'PY'
import json
import sys
from datetime import datetime, timezone

path, question, cmd, why, model = sys.argv[1:6]
data = {
    "question": question,
    "cmd": cmd,
    "timestamp": datetime.now(timezone.utc).isoformat(),
}
if why:
    data["why"] = why
if model:
    data["model"] = model

with open(path, "w", encoding="utf-8") as f:
    json.dump(data, f)
PY
  status=$?
  if [[ $status -eq 0 ]]; then
    mv "$tmp_file" "$state_file" >/dev/null 2>&1 || true
  else
    rm -f "$tmp_file"
  fi
  set -e
}

explain=0
raw=0
model=""
args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --explain)
      explain=1
      shift
      ;;
    --no-explain)
      explain=0
      shift
      ;;
    --raw)
      raw=1
      shift
      ;;
    --model)
      if [[ $# -lt 2 ]]; then
        usage
        exit 1
      fi
      model="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      args+=("$@")
      break
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done

if [[ ${#args[@]} -eq 0 ]]; then
  usage
  exit 1
fi

if ! command -v llm >/dev/null 2>&1; then
  echo "asksh: llm not found in PATH" >&2
  exit 127
fi

user_request="${args[*]}"

clarifications=""
read_last_context
last_context=""
if [[ -n "$last_cmd" ]]; then
  last_context=$(cat <<EOF
Previous command context (may be unrelated; ignore unless the user indicates a failure or correction):
- Previous request: ${last_question}
- Previous command: ${last_cmd}
${last_why:+- Previous explanation: ${last_why}}
EOF
)
fi

while :; do
  prompt=$(cat <<PROMPT
You are a shell-command generator. Follow the rules strictly.
Rules:
- Output exactly one of the formats below and nothing else.
- No markdown, no code fences, no backticks, no extra commentary.
Format A:
CMD: <single-line shell command>
WHY: <optional short explanation, max 100 chars>
Format B:
NEED_MORE_INFO: <single short clarification question>
Only output one CMD line. Prefer bash-compatible, safe, concise commands.
User request: ${user_request}
${clarifications:+Clarifications:
$clarifications}
${last_context:+
$last_context}
PROMPT
  )

  llm_stderr="$(mktemp)"
  set +e
  start_spinner
  if [[ -n "$model" ]]; then
    llm_output=$(llm -m "$model" "$prompt" 2>"$llm_stderr")
  else
    llm_output=$(llm "$prompt" 2>"$llm_stderr")
  fi
  status=$?
  set -e
  stop_spinner

  if [[ $status -ne 0 ]]; then
    echo "asksh: llm failed ($status)" >&2
    if [[ -s "$llm_stderr" ]]; then
      cat "$llm_stderr" >&2
    fi
    rm -f "$llm_stderr"
    exit "$status"
  fi
  rm -f "$llm_stderr"

  if [[ $raw -eq 1 ]]; then
    printf '%s\n' "$llm_output"
    exit 0
  fi

  cmd=""
  why=""
  need=""

  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    if [[ -z "$cmd" && "$line" == CMD:* ]]; then
      cmd="${line#CMD:}"
      cmd="${cmd# }"
      continue
    fi
    if [[ -z "$why" && "$line" == WHY:* ]]; then
      why="${line#WHY:}"
      why="${why# }"
      continue
    fi
    if [[ -z "$need" && "$line" == NEED_MORE_INFO:* ]]; then
      need="${line#NEED_MORE_INFO:}"
      need="${need# }"
    fi
  done <<<"$llm_output"

  if [[ -n "$cmd" ]]; then
    write_last_context
    print_command
    if [[ $explain -eq 1 && -n "$why" ]]; then
      printf '%s\n' "$why"
    fi
    prompt_copy_to_clipboard
    exit 0
  fi

  if [[ -n "$need" ]]; then
    if [[ -t 0 ]]; then
      printf 'NEED_MORE_INFO: %s\n' "$need" >&2
      printf '> ' >&2
      if ! IFS= read -r user_answer; then
        printf 'NEED_MORE_INFO: %s\n' "$need"
        exit 2
      fi
      if [[ -n "$clarifications" ]]; then
        clarifications+=$'\n'
      fi
      clarifications+="Q: $need"$'\n'"A: $user_answer"
      continue
    fi
    printf 'NEED_MORE_INFO: %s\n' "$need"
    exit 2
  fi

  printf 'NEED_MORE_INFO: Please rephrase your request\n'
  exit 2
done
